/*
 * Copyright (c) 2018 Yubico AB. All rights reserved.
 * Use of this source code is governed by a BSD-style
 * license that can be found in the LICENSE file.
 */

#include <sys/types.h>
#include <sys/stat.h>

#include <openssl/ec.h>
#include <openssl/evp.h>
#include <openssl/pem.h>

#include <fido.h>
#include <fido/es256.h>
#include <fido/rs256.h>
#include <fido/eddsa.h>

#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "../openbsd-compat/openbsd-compat.h"
#include "extern.h"

void
read_pin(const char *path, char *buf, size_t len)
{
	char prompt[1024];
	int r;

	r = snprintf(prompt, sizeof(prompt), "Enter PIN for %s: ", path);
	if (r < 0 || (size_t)r >= sizeof(prompt))
		errx(1, "snprintf");
	if (!readpassphrase(prompt, buf, len, RPP_ECHO_OFF))
		errx(1, "readpassphrase");
}

FILE *
open_write(const char *file)
{
	int fd;
	FILE *f;

	if (file == NULL || strcmp(file, "-") == 0)
		return (stdout);
	if ((fd = open(file, O_WRONLY | O_CREAT, 0600)) < 0)
		err(1, "open %s", file);
	if ((f = fdopen(fd, "w")) == NULL)
		err(1, "fdopen %s", file);

	return (f);
}

FILE *
open_read(const char *file)
{
	int fd;
	FILE *f;

	if (file == NULL || strcmp(file, "-") == 0) {
#ifdef FIDO_FUZZ
		setvbuf(stdin, NULL, _IONBF, 0);
#endif
		return (stdin);
	}
	if ((fd = open(file, O_RDONLY)) < 0)
		err(1, "open %s", file);
	if ((f = fdopen(fd, "r")) == NULL)
		err(1, "fdopen %s", file);

	return (f);
}

void
xxd(const void *buf, size_t count)
{
	const uint8_t	*ptr = buf;
	size_t		 i;

	fprintf(stderr, "  ");

	for (i = 0; i < count; i++) {
		fprintf(stderr, "%02x ", *ptr++);
		if ((i + 1) % 16 == 0 && i + 1 < count)
			fprintf(stderr, "\n  ");
	}

	fprintf(stderr, "\n");
	fflush(stderr);
}

int
string_read(FILE *f, char **out)
{
	char *line = NULL;
	size_t linesize = 0;
	ssize_t n;

	*out = NULL;

	if ((n = getline(&line, &linesize, f)) <= 0 ||
	    (size_t)n != strlen(line)) {
		free(line);
		return (-1);
	}

	line[n - 1] = '\0'; /* trim \n */
	*out = line;

	return (0);
}

#include "vpcd.h"

static unsigned char *rapdu = NULL;
static ssize_t rapdu_len = 0;

static void hexdump(const char *title, const unsigned char *s, size_t l)
{
    size_t n=0;

    fprintf(stdout,"%s",title);

    if (!s) {
        fprintf(stdout,"(null)\n");
    } else {
        for(; n < l; ++n)
        {
            if((n%16) == 0)
                fprintf(stdout,"\n    ");
            fprintf(stdout,"%02x:",(unsigned char) s[n]);
        }
        fprintf(stdout,"\n");
    }
}

static void *
dummy_open(const char *path)
{
	(void)path;

	struct vicc_ctx *ctx = vicc_init(NULL, 35969);

	if (vicc_connect(ctx, 20, 0)) {
		rapdu_len = 0;
	} else {
		vicc_exit(ctx);
		return NULL;
	}

	unsigned char create[] = {0x80, 0xB8, 0x00, 0x00, 0x0A, 0x08, 0xA0, 0x00, 0x00, 0x06, 0x47, 0x2F, 0x00, 0x01, 0x00, 0x00};
	hexdump("create", create, sizeof create);
	rapdu_len = vicc_transmit(ctx, sizeof create, create, &rapdu);
	if (rapdu_len < 0) {
		return NULL;
	}
	hexdump("create rapdu", rapdu, rapdu_len);

	unsigned char select[] = {0x00, 0xA4, 0x04, 0x00, 0x08, 0xA0, 0x00, 0x00, 0x06, 0x47, 0x2f, 0x00, 0x01, 0x00};

	hexdump("select", select, sizeof select);
	rapdu_len = vicc_transmit(ctx, sizeof select, select, &rapdu);
	if (rapdu_len < 0) {
		return NULL;
	}
	hexdump("select rapdu", rapdu, rapdu_len);

	unsigned char init[] = {
		0x80, 0x10, 0x00, 0x00, 0x00, 0x02, 0x34, 0x40, 0xe7, 0xee, 0x03, 0x56,
		0x17, 0x35, 0x6c, 0xc6, 0xdc, 0x2b, 0x98, 0x4d, 0xf2, 0xf6, 0xcc, 0x21,
		0x5e, 0x39, 0x05, 0x52, 0x1f, 0xa5, 0x29, 0x87, 0x30, 0xde, 0xd0, 0xa1,
		0x09, 0xfd, 0x1b, 0x30, 0x30, 0x82, 0x02, 0x0f, 0x30, 0x82, 0x01, 0xb6,
		0xa0, 0x03, 0x02, 0x01, 0x02, 0x02, 0x14, 0x70, 0x45, 0xfd, 0x6d, 0x82,
		0x1a, 0x41, 0x13, 0xbf, 0xe6, 0x48, 0x72, 0xd5, 0x0a, 0xd9, 0x54, 0x30,
		0x56, 0xe0, 0xb7, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d,
		0x04, 0x03, 0x02, 0x30, 0x5f, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,
		0x04, 0x06, 0x13, 0x02, 0x44, 0x45, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03,
		0x55, 0x04, 0x08, 0x0c, 0x06, 0x42, 0x65, 0x72, 0x6c, 0x69, 0x6e, 0x31,
		0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x06, 0x42, 0x65,
		0x72, 0x6c, 0x69, 0x6e, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04,
		0x0a, 0x0c, 0x0f, 0x46, 0x49, 0x44, 0x4f, 0x32, 0x2d, 0x54, 0x65, 0x73,
		0x74, 0x2d, 0x43, 0x65, 0x72, 0x74, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03,
		0x55, 0x04, 0x03, 0x0c, 0x0b, 0x4d, 0x61, 0x6c, 0x74, 0x65, 0x20, 0x4b,
		0x72, 0x75, 0x73, 0x65, 0x30, 0x1e, 0x17, 0x0d, 0x31, 0x39, 0x30, 0x36,
		0x31, 0x32, 0x30, 0x38, 0x35, 0x39, 0x35, 0x36, 0x5a, 0x17, 0x0d, 0x32,
		0x31, 0x30, 0x36, 0x31, 0x31, 0x30, 0x38, 0x35, 0x39, 0x35, 0x36, 0x5a,
		0x30, 0x5f, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,
		0x02, 0x44, 0x45, 0x31, 0x0f, 0x30, 0x0d, 0x06, 0x03, 0x55, 0x04, 0x08,
		0x0c, 0x06, 0x42, 0x65, 0x72, 0x6c, 0x69, 0x6e, 0x31, 0x0f, 0x30, 0x0d,
		0x06, 0x03, 0x55, 0x04, 0x07, 0x0c, 0x06, 0x42, 0x65, 0x72, 0x6c, 0x69,
		0x6e, 0x31, 0x18, 0x30, 0x16, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x0c, 0x0f,
		0x46, 0x49, 0x44, 0x4f, 0x32, 0x2d, 0x54, 0x65, 0x73, 0x74, 0x2d, 0x43,
		0x65, 0x72, 0x74, 0x31, 0x14, 0x30, 0x12, 0x06, 0x03, 0x55, 0x04, 0x03,
		0x0c, 0x0b, 0x4d, 0x61, 0x6c, 0x74, 0x65, 0x20, 0x4b, 0x72, 0x75, 0x73,
		0x65, 0x30, 0x56, 0x30, 0x10, 0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d,
		0x02, 0x01, 0x06, 0x05, 0x2b, 0x81, 0x04, 0x00, 0x0a, 0x03, 0x42, 0x00,
		0x04, 0x07, 0x91, 0x40, 0xf8, 0xa9, 0x4b, 0xbb, 0xa4, 0x49, 0x1d, 0xfc,
		0x62, 0x6f, 0xae, 0x16, 0x1f, 0x74, 0x13, 0x2c, 0x15, 0x1e, 0x2b, 0x47,
		0x13, 0x02, 0x90, 0xaf, 0x66, 0xca, 0xa8, 0x37, 0xa5, 0x0b, 0xc8, 0xf7,
		0x9e, 0x8c, 0xe0, 0xb1, 0x31, 0x39, 0xaf, 0xc1, 0xa4, 0x7b, 0xa7, 0x10,
		0x42, 0x30, 0xf5, 0x47, 0xeb, 0x93, 0xeb, 0xb7, 0x8a, 0x03, 0x04, 0x3e,
		0xb2, 0x2f, 0x8c, 0xd8, 0x95, 0xa3, 0x53, 0x30, 0x51, 0x30, 0x1d, 0x06,
		0x03, 0x55, 0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0x9c, 0x52, 0x6d, 0x86,
		0x7f, 0x1d, 0xf4, 0x0f, 0x54, 0x16, 0xf1, 0x18, 0x27, 0x70, 0x2f, 0x3b,
		0x45, 0x74, 0xfc, 0x7d, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x1d, 0x23, 0x04,
		0x18, 0x30, 0x16, 0x80, 0x14, 0x9c, 0x52, 0x6d, 0x86, 0x7f, 0x1d, 0xf4,
		0x0f, 0x54, 0x16, 0xf1, 0x18, 0x27, 0x70, 0x2f, 0x3b, 0x45, 0x74, 0xfc,
		0x7d, 0x30, 0x0f, 0x06, 0x03, 0x55, 0x1d, 0x13, 0x01, 0x01, 0xff, 0x04,
		0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30, 0x0a, 0x06, 0x08, 0x2a, 0x86,
		0x48, 0xce, 0x3d, 0x04, 0x03, 0x02, 0x03, 0x47, 0x00, 0x30, 0x44, 0x02,
		0x20, 0x56, 0x10, 0x0f, 0xae, 0xd0, 0xcc, 0x32, 0x25, 0x81, 0xc3, 0x97,
		0xd2, 0x28, 0x5b, 0xf6, 0x23, 0x9d, 0xe3, 0x6d, 0x6c, 0xc1, 0x0a, 0x15,
		0x57, 0xa5, 0x56, 0xed, 0x2f, 0x8b, 0xb3, 0x0b, 0x1b, 0x02, 0x20, 0x1f,
		0x23, 0x42, 0xf2, 0x6c, 0x70, 0x44, 0xd4, 0x3a, 0x37, 0x3e, 0x56, 0x17,
		0x76, 0x49, 0xe4, 0x16, 0x07, 0xca, 0x81, 0x56, 0x06, 0x60, 0x06, 0x1e,
		0x99, 0x51, 0xbd, 0xb0, 0x4f, 0x9e, 0x1e, 0x00, 0x00,
	};
	hexdump("init", init, sizeof init);
	rapdu_len = vicc_transmit(ctx, sizeof init, init, &rapdu);
	if (rapdu_len < 0) {
		return NULL;
	}
	hexdump("init rapdu", rapdu, rapdu_len);

	return ctx;
}

static void
dummy_close(void *handle)
{
	rapdu_len = 0;
	vicc_exit(handle);
}

static int
dummy_read(void *handle, unsigned char *buf, size_t len, int ms)
{
	(void)ms;
	(void)handle;

	if (rapdu_len < 0) {
		return (-1);
	}
	if (len < (size_t) rapdu_len) {
		return (-1);
	}
	memcpy(buf, rapdu, rapdu_len);
	hexdump("read", rapdu, rapdu_len);

	return rapdu_len;
}

static int
dummy_write(void *handle, const unsigned char *buf, size_t len)
{
	hexdump("apdu", buf, len);
	rapdu_len = vicc_transmit(handle, len, buf, &rapdu);
	if (rapdu_len < 0) {
		return (-1);
	}
	hexdump("rapdu", rapdu, rapdu_len);
	return len;
}

void set_vicc(fido_dev_t *dev);
void set_vicc(fido_dev_t *dev)
{
	fido_dev_io_t io_f;

	io_f.open = dummy_open;
	io_f.close = dummy_close;
	io_f.read = dummy_read;
	io_f.write = dummy_write;

	fido_dev_force_fido2(dev);
	fido_dev_set_io_functions(dev, &io_f);
}

fido_dev_t *
open_dev(const char *path)
{
	fido_dev_t *dev;
	int r;

	if ((dev = fido_dev_new()) == NULL)
		errx(1, "fido_dev_new");

	set_vicc(dev);

	r = fido_dev_open(dev, path);
	if (r != FIDO_OK)
		errx(1, "fido_dev_open %s: %s", path, fido_strerr(r));

	return (dev);
}

EC_KEY *
read_ec_pubkey(const char *path)
{
	FILE *fp = NULL;
	EVP_PKEY *pkey = NULL;
	EC_KEY *ec = NULL;

	if ((fp = fopen(path, "r")) == NULL) {
		warn("fopen");
		goto fail;
	}

	if ((pkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {
		warnx("PEM_read_PUBKEY");
		goto fail;
	}
	if ((ec = EVP_PKEY_get1_EC_KEY(pkey)) == NULL) {
		warnx("EVP_PKEY_get1_EC_KEY");
		goto fail;
	}

fail:
	if (fp) {
		fclose(fp);
	}
	if (pkey) {
		EVP_PKEY_free(pkey);
	}

	return (ec);
}

int
write_ec_pubkey(FILE *f, const void *ptr, size_t len)
{
	EVP_PKEY *pkey = NULL;
	es256_pk_t *pk = NULL;
	int ok = -1;

	if ((pk = es256_pk_new()) == NULL) {
		warnx("es256_pk_new");
		goto fail;
	}

	if (es256_pk_from_ptr(pk, ptr, len) != FIDO_OK) {
		warnx("es256_pk_from_ptr");
		goto fail;
	}

	if ((pkey = es256_pk_to_EVP_PKEY(pk)) == NULL) {
		warnx("es256_pk_to_EVP_PKEY");
		goto fail;
	}

	if (PEM_write_PUBKEY(f, pkey) == 0) {
		warnx("PEM_write_PUBKEY");
		goto fail;
	}

	ok = 0;
fail:
	es256_pk_free(&pk);

	if (pkey != NULL) {
		EVP_PKEY_free(pkey);
	}

	return (ok);
}

RSA *
read_rsa_pubkey(const char *path)
{
	FILE *fp = NULL;
	EVP_PKEY *pkey = NULL;
	RSA *rsa = NULL;

	if ((fp = fopen(path, "r")) == NULL) {
		warn("fopen");
		goto fail;
	}

	if ((pkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {
		warnx("PEM_read_PUBKEY");
		goto fail;
	}
	if ((rsa = EVP_PKEY_get1_RSA(pkey)) == NULL) {
		warnx("EVP_PKEY_get1_RSA");
		goto fail;
	}

fail:
	if (fp) {
		fclose(fp);
	}
	if (pkey) {
		EVP_PKEY_free(pkey);
	}

	return (rsa);
}

int
write_rsa_pubkey(FILE *f, const void *ptr, size_t len)
{
	EVP_PKEY *pkey = NULL;
	rs256_pk_t *pk = NULL;
	int ok = -1;

	if ((pk = rs256_pk_new()) == NULL) {
		warnx("rs256_pk_new");
		goto fail;
	}

	if (rs256_pk_from_ptr(pk, ptr, len) != FIDO_OK) {
		warnx("rs256_pk_from_ptr");
		goto fail;
	}

	if ((pkey = rs256_pk_to_EVP_PKEY(pk)) == NULL) {
		warnx("rs256_pk_to_EVP_PKEY");
		goto fail;
	}

	if (PEM_write_PUBKEY(f, pkey) == 0) {
		warnx("PEM_write_PUBKEY");
		goto fail;
	}

	ok = 0;
fail:
	rs256_pk_free(&pk);

	if (pkey != NULL) {
		EVP_PKEY_free(pkey);
	}

	return (ok);
}

EVP_PKEY *
read_eddsa_pubkey(const char *path)
{
	FILE *fp = NULL;
	EVP_PKEY *pkey = NULL;

	if ((fp = fopen(path, "r")) == NULL) {
		warn("fopen");
		goto fail;
	}

	if ((pkey = PEM_read_PUBKEY(fp, NULL, NULL, NULL)) == NULL) {
		warnx("PEM_read_PUBKEY");
		goto fail;
	}

fail:
	if (fp) {
		fclose(fp);
	}

	return (pkey);
}

int
write_eddsa_pubkey(FILE *f, const void *ptr, size_t len)
{
	EVP_PKEY *pkey = NULL;
	eddsa_pk_t *pk = NULL;
	int ok = -1;

	if ((pk = eddsa_pk_new()) == NULL) {
		warnx("eddsa_pk_new");
		goto fail;
	}

	if (eddsa_pk_from_ptr(pk, ptr, len) != FIDO_OK) {
		warnx("eddsa_pk_from_ptr");
		goto fail;
	}

	if ((pkey = eddsa_pk_to_EVP_PKEY(pk)) == NULL) {
		warnx("eddsa_pk_to_EVP_PKEY");
		goto fail;
	}

	if (PEM_write_PUBKEY(f, pkey) == 0) {
		warnx("PEM_write_PUBKEY");
		goto fail;
	}

	ok = 0;
fail:
	eddsa_pk_free(&pk);

	if (pkey != NULL) {
		EVP_PKEY_free(pkey);
	}

	return (ok);
}

void
print_cred(FILE *out_f, int type, const fido_cred_t *cred)
{
	char *id;
	int r;

	r = base64_encode(fido_cred_id_ptr(cred), fido_cred_id_len(cred), &id);
	if (r < 0)
		errx(1, "output error");

	fprintf(out_f, "%s\n", id);

	if (type == COSE_ES256) {
		write_ec_pubkey(out_f, fido_cred_pubkey_ptr(cred),
		    fido_cred_pubkey_len(cred));
	} else if (type == COSE_RS256) {
		write_rsa_pubkey(out_f, fido_cred_pubkey_ptr(cred),
		    fido_cred_pubkey_len(cred));
	} else if (type == COSE_EDDSA) {
		write_eddsa_pubkey(out_f, fido_cred_pubkey_ptr(cred),
		    fido_cred_pubkey_len(cred));
	} else {
		errx(1, "print_cred: unknown type");
	}

	free(id);
}
